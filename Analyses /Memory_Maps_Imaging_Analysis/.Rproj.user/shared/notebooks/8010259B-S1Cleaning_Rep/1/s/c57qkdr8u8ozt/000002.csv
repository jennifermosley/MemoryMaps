"0","```r
  uIds <- unique(rawDf$subID)
  # column names
  idSubs <- rawDf %>%
    select(contains(\"_Relations\"))

  # Subjects to remove based on network
  removeSubs <- c()
  for(n in 1:nrow(rawDf)){
    i <- rawDf$subID[n]
    
    idNames <- memMat[memMat$subID==i,2:31] %>% as_vector() %>% na.omit()
    numMems <- sum(!is.na(memMat[memMat$subID==i,2:31]))
    
    # subset subject row
    subDf <- rawDf[rawDf$subID==i,]
    # generate empty matrix
    subMat <- matrix(data = 0, nrow = numMems, ncol = numMems)
    subMatW <- matrix(data = 0, nrow = numMems, ncol = numMems)
    for(c in 1:numMems){
      # subset identity \"c\"
      j <- idSubs[n,c]
      # split words by comma
      selectWord <-strsplit(as.character(idSubs[n,c][[1]]),\",\") 
      if(length(selectWord[[1]])==0){
        next
      }
      
      # which column index are select identities
      ######rowSub <-which(idNames %in% selectWord[[1]])
      # populate 1s for select identities in row and column for undirected
      subMat[as.numeric(unlist(selectWord)),c] <- 1 # Unweighted matrix
      diag(subMat) <- 0 # Set diagonal to 0s if participants nominated any self-connections
      for(p in unlist(selectWord)){
        
      if(subMatW[as.numeric(unlist(p)),c]==0){
        
        subMatW[as.numeric(unlist(p)),c]  <- as.numeric ( rawDf[n,paste0(\"M\",c,\"_Sim_\",as.numeric(unlist(p) ))] ) # Weighted matrix
        
      }else if(subMatW[as.numeric(unlist(p)),c]>0){
        
        subMatW[as.numeric(unlist(p)),c]  <- mean(c(subMatW[as.numeric(unlist(p)),c], as.numeric ( rawDf[n,paste0(\"M\",c,\"_Sim_\",as.numeric(unlist(p) ))] )  )) # Weighted matrix
        
      }
        
      }
      # if participant didn't indicate weight, replace with 0
      subMatW[is.na(subMatW)] <- 0
      # Flipped direction of fraction so more overlap is closer between identities
      
      diag(subMatW) <- 0 # Set diagonal to 0s if participants nominated any self-connections
  }
    rownames(subMat) <- idNames
    colnames(subMat) <- idNames
    
    rownames(subMatW) <- idNames
    colnames(subMatW) <- idNames
  
      # convert to graph
    subGraph <- graph.adjacency(subMat, mode=\"directed\")
    subGraphW <- graph.adjacency(subMatW, weighted = T, mode=\"directed\")
    
    # coerce to undirected
    # subGraph.UD.C <- as.undirected(subGraph, mode=\"collapse\")
    # subGraph.UD.M <- as.undirected(subGraph, mode=\"mutual\")
    # subGraphW.UD.C <- as.undirected(subGraphW, mode=\"collapse\")
    # subGraphW.UD.M <- as.undirected(subGraphW, mode=\"mutual\")
    
    # label
    assign(paste0(\"subIMat.\",i),subMat)
    assign(paste0(\"subIGraph.\",i),subGraph)
    
    assign(paste0(\"subIMatW.\",i),subMatW)
    assign(paste0(\"subIGraphW.\",i),subGraphW)
    
    # label undirected
    # assign(paste0(\"subGraph.UD.C.\",i),subGraph.UD.C)
    # assign(paste0(\"subGraph.UD.M.\",i),subGraph.UD.M)
    # assign(paste0(\"subGraphW.UD.C.\",i),subGraphW.UD.C)
    # assign(paste0(\"subGraphW.UD.M.\",i),subGraphW.UD.M)
    
    if(length(E(subGraph))==0 | length(V(subGraph)) < 4 ){
      removeSubs <- c(removeSubs, i)
      rm(list = c(paste0(\"subIGraph.\",i)))
      rm(list = c(paste0(\"subIGraphW.\",i)))
      rm(list = c(paste0(\"subIMat.\",i)))
      rm(list = c(paste0(\"subIMatW.\",i)))
      
      # rm(list = c(paste0(\"subGraph.UD.C.\",i)))
      # rm(list = c(paste0(\"subGraph.UD.M.\",i)))
      # rm(list = c(paste0(\"subGraphW.UD.C.\",i)))
      # rm(list = c(paste0(\"subGraphW.UD.M.\",i)))
    }
    
  }
  
```"
